// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, LArray, LBase, LValue, RArray, RValue, Scuttlebucket, Scuttlebutt, between, dutyOfSubclass, filter, hat, order, ss, through, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  EventEmitter = require('events').EventEmitter;

  Scuttlebucket = require('scuttlebucket');

  Scuttlebutt = require('scuttlebutt');

  filter = require('scuttlebutt/util').filter;

  through = require('through');

  between = require('between');

  RArray = require('r-array');

  RValue = require('r-value');

  util = require('util');

  hat = require('hat');

  ss = require('stream-serializer');

  order = function(a, b) {
    return between.strord(a[1], b[1]) || between.strord(a[2], b[2]);
  };

  dutyOfSubclass = function(name) {
    return function() {
      throw new Error("" + this.constructor.name + "." + name + " must be implemented");
    };
  };

  LBase = (function(_super) {
    __extends(LBase, _super);

    function LBase() {
      _ref = LBase.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    LBase.types = {};

    LBase.register = function(type) {
      return this.types[type.name.toLowerCase()] = type;
    };

    LBase.create = function() {
      var args, name, _base;
      name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return typeof (_base = this.types)[name] === "function" ? (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(_base[name], args, function(){}) : void 0;
    };

    LBase.prototype.pipe = function(dest) {
      this.createReadStream().pipe(dest.createWriteStream());
      return dest;
    };

    LBase.prototype.map = function() {
      var args, fn, newLive, _ref1;
      fn = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      newLive = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this.constructor, this.constructor.mapCreationArgs(fn, this.creationArgs()), function(){});
      this.createReadStream().pipe((_ref1 = this.constructor).mapper.apply(_ref1, [fn].concat(__slice.call(args)))).pipe(newLive.createWriteStream());
      return newLive;
    };

    LBase.prototype.creationArgs = dutyOfSubclass('creationArgs');

    LBase.prototype.applyUpdate = dutyOfSubclass('applyUpdate');

    LBase.prototype.history = dutyOfSubclass('history');

    return LBase;

  })(Scuttlebutt);

  LArray = (function(_super) {
    __extends(LArray, _super);

    function LArray() {
      var val, vals, _i, _len,
        _this = this;
      vals = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      LArray.__super__.constructor.call(this);
      this._sb = new RArray;
      this._db = {};
      this._rack = hat.rack();
      this.length = new LValue(0);
      this._hist = {};
      this._historyMap = {};
      this._updateBuffer = {};
      this._sbKeys = {};
      this._dbKeys = {};
      this._sb.on('update', function(rawUpdate) {
        var key, sbKey, update;
        update = {};
        for (sbKey in rawUpdate) {
          key = rawUpdate[sbKey];
          update[key] = _this._db[key];
        }
        for (sbKey in rawUpdate) {
          key = rawUpdate[sbKey];
          if (key != null) {
            _this._sbKeys[key] = sbKey;
            _this._dbKeys[sbKey] = key;
          }
        }
        _this.emit('update', update);
        for (sbKey in rawUpdate) {
          key = rawUpdate[sbKey];
          if ((key != null) && (update[key] != null)) {
            if (_this._updateBuffer[key] != null) {
              _this.emit('update', _this._sb.indexOfKey(sbKey), update[key], key, sbKey);
            } else {
              _this.length.set(_this._sb.length);
              _this.emit('insert', _this._sb.indexOfKey(sbKey), update[key], key, sbKey);
            }
            _this._updateBuffer[key] = update[key];
          } else {
            key = _this._dbKeys[sbKey];
            if ((_this._updateBuffer[key] != null) || (_this._db[key] != null)) {
              _this.length.set(_this._sb.length);
              _this.emit('remove', _this._sb.indexOfKey(sbKey), _this._updateBuffer[key] || _this._db[key], key, sbKey);
            } else {

            }
          }
        }
        for (sbKey in rawUpdate) {
          key = rawUpdate[sbKey];
          if (key == null) {
            key = _this._dbKeys[sbKey];
            delete _this._dbKeys[sbKey];
            delete _this._sbKeys[key];
            delete _this._updateBuffer[key];
            delete _this._hist[key];
            process.nextTick((function(key) {
              return delete this._db[key];
            }).bind(_this, key));
          }
        }
      });
      this._sb.on('_update', function(update) {
        return _this.localUpdate(['a', update]);
      });
      for (_i = 0, _len = vals.length; _i < _len; _i++) {
        val = vals[_i];
        this.push(val);
      }
    }

    LArray.prototype.creationArgs = function() {
      return [];
    };

    LArray.mapCreationArgs = function(fn, args) {
      return [];
    };

    LArray.prototype._genId = function() {
      return this._rack();
    };

    LArray.prototype._register = function(val, key, update) {
      var _this = this;
      if (key == null) {
        key = this._genId();
      }
      if (update == null) {
        update = true;
      }
      if (update) {
        this.localUpdate(['d', key, val.constructor.name.toLowerCase(), val.creationArgs()]);
      }
      this._db[key] = val;
      val.on('_update', function(update) {
        if (_this._db[key] === val) {
          return _this.localUpdate(['c', key, update]);
        }
      });
      return key;
    };

    LArray.prototype._setIndex = function(index, key) {
      return this._sb.set(this._sb.keys[index], key);
    };

    LArray.prototype._unset = function(key) {
      return this._sb.unset(this._sbKeys[key]);
    };

    LArray.prototype.push = function(val) {
      var key;
      key = this._register(val);
      this._sb.push(key);
      return this;
    };

    LArray.prototype.unshift = function(val) {
      var key;
      key = this._register(val);
      this._sb.unshift(key);
      return this;
    };

    LArray.prototype.get = function(index) {
      return this._db[this._sb.get(this._sb.keys[index])];
    };

    LArray.prototype.pop = function() {
      var key;
      key = this._sb.pop();
      return this._db[key];
    };

    LArray.prototype.shift = function() {
      var key;
      key = this._sb.shift();
      return this._db[key];
    };

    LArray.prototype.remove = function(index) {
      this._sb.unset(this._sb.keys[index]);
      return this;
    };

    LArray.prototype.forEach = function(fn) {
      var i, _i, _ref1;
      for (i = _i = 0, _ref1 = this.length.get() - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        fn.call(this, this.get(i), i);
      }
      return this;
    };

    LArray.prototype.each = function(fn) {
      return this.forEach(fn);
    };

    LArray.mapper = function(fn, subArgs) {
      var db, dbKeys;
      if (subArgs == null) {
        subArgs = [];
      }
      db = {};
      dbKeys = {};
      return ss.json(through(function(update) {
        var childUpdate, data, key, mapper, sbKey, _ref1, _ref2,
          _this = this;
        if (Array.isArray(update)) {
          data = update[0];
          switch (data[0]) {
            case 'c':
              childUpdate = data[2].slice();
              childUpdate.args = [data[1]];
              childUpdate.custom = update;
              if (Array.isArray(update.args)) {
                childUpdate.args = childUpdate.args.concat(update.args);
              }
              return (_ref1 = db[data[1]]) != null ? _ref1.write(JSON.stringify(childUpdate)) : void 0;
            case 'd':
              mapper = (_ref2 = LBase.types[data[2]]).mapper.apply(_ref2, [fn].concat(__slice.call(subArgs)));
              mapper.on('data', function(update) {
                return _this.queue([['c', data[1], update], update.custom[1][1], update.custom[1][2]]);
              });
              db[data[1]] = mapper;
              return this.queue([['d', data[1], data[2], LBase.types[data[2]].mapCreationArgs(fn, data[3], data[1])], update[1], update[2]]);
            default:
              for (sbKey in data) {
                key = data[sbKey];
                if (key != null) {
                  dbKeys[sbKey] = key;
                } else {
                  delete db[dbKeys[sbKey]];
                  delete dbKeys[sbKey];
                }
              }
              return this.queue(update);
          }
        } else {
          return this.queue(update);
        }
      }));
    };

    LArray.prototype.history = function(sources) {
      var hist, key, update, val, _ref1, _ref2,
        _this = this;
      hist = this._sb.history(sources).map(function(update) {
        return _this._historyMap["" + update[2] + "-" + update[1]];
      });
      _ref1 = this._hist;
      for (key in _ref1) {
        update = _ref1[key];
        if (!~hist.indexOf(update) && filter(update, sources)) {
          hist.push(update);
        }
      }
      _ref2 = this._db;
      for (key in _ref2) {
        val = _ref2[key];
        hist = hist.concat(val.history(sources).map(function(update) {
          return _this._historyMap["" + key + "-" + update[2] + "-" + update[1]];
        }));
      }
      return hist.filter(Boolean).sort(order);
    };

    LArray.prototype.applyUpdate = function(update) {
      var data, _ref1;
      data = update[0];
      switch (data[0]) {
        case 'a':
          this._historyMap["" + data[1][2] + "-" + data[1][1]] = update;
          return this._sb.applyUpdate(data[1]);
        case 'd':
          this._hist[data[1]] = update;
          if (this._db[data[1]] == null) {
            this._register(LBase.create.apply(LBase, [data[2]].concat(__slice.call(data[3]))), data[1], false);
          }
          this.emit('_register', data[1], this._db[data[1]]);
          return true;
        case 'c':
          this._historyMap["" + data[1] + "-" + data[2][2] + "-" + data[2][1]] = update;
          if (update[2] !== this.id) {
            if ((_ref1 = this._db[data[1]]) != null) {
              _ref1._update(data[2]);
            }
          }
          return true;
      }
    };

    return LArray;

  })(LBase);

  LBase.Array = LArray;

  LBase.register(LArray);

  LValue = (function(_super) {
    __extends(LValue, _super);

    function LValue(defaultVal, force) {
      var _this = this;
      if (force == null) {
        force = false;
      }
      LValue.__super__.constructor.call(this);
      this._sb = new RValue;
      this._sb.on('update', function(data) {
        return _this.emit('update', data);
      });
      this._sb.on('_update', function(update) {
        return _this.emit('_update', update);
      });
      if (defaultVal != null) {
        this.set(defaultVal);
      }
    }

    LValue.prototype.creationArgs = function() {
      return [this.get()];
    };

    LValue.mapCreationArgs = function() {
      var args, fn, subArgs;
      fn = arguments[0], args = arguments[1], subArgs = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return [fn.apply(null, [args[0]].concat(__slice.call(subArgs)))];
    };

    LValue.prototype.set = function(newValue) {
      if (this.get() !== newValue) {
        this._sb.set(newValue);
      }
      return this;
    };

    LValue.prototype.get = function() {
      return this._sb.get();
    };

    LValue.mapper = function(fn) {
      return ss.json(through(function(update) {
        var args, newUpdate;
        return this.queue(Array.isArray(update) ? (args = [update[0]], Array.isArray(update.args) ? args = args.concat(update.args) : void 0, newUpdate = [fn.apply(null, args), update[1], update[2]], newUpdate.custom = update.custom, newUpdate) : update);
      }));
    };

    LValue.prototype.history = function(sources) {
      return this._sb.history(sources);
    };

    LValue.prototype.applyUpdate = function(update) {
      return this._sb.applyUpdate(update);
    };

    return LValue;

  })(LBase);

  LBase.Value = LValue;

  LBase.register(LValue);

  module.exports = LBase;

}).call(this);
